CH1

函数
形参 formal parameter  int func (a, b, c) 
指的是在函数定义或函数声明的括号内。
实参 value parameter.  r=func (x,y,z)
指的是在函数调用时的括号内。
引用参数 reference parameter 普通引用 int&
int func(int& a, int& b)
双向：既读取数据，又想修改原始数据。
函数内行为: 可以给 a 赋值，会改变外面的实参。
实参限制 严格：只能传变量（左值）
引用常量 const reference const int&
int func(const int& a, const int& b)
单向：只读取数据，保证不修改原始数据。
不能给 a 赋值（只读）。
宽容：既传变量，也可以传常量、数字、表达式（右值）。


函数传入方式
按值传入func(T a)
函数按值传入时会创建副本，作用域结束时会调用析构函数。
形参的值不会修改实惨 复制过程由型参类型的 复制构造函数 来完成
函数运行结束时，型参类型的析构函数会释放形式参数，形式参数不会被复制到实际参数中，因此调用函数不会修改于型参对应的数值
总结： 这样操作每次都要复制 "实参 到 形参"，每次结束都要调用类型的析构函数，很浪费资源和效率。
型参不会影响到实参原数据
引用传入func(T& a)
不创建副本，(因为不需要像按值传入创建副本) 也不需要调用析构函数在结束时
提高性能!!!!!但参数的值会影响原来数据
常量引用传入 const.  func(const T& a)
不会修改引用的原数据



返回值
return by value 
返回时会生成一个副本，把副本拷贝(复制构造函数)到调用者，之后调用（析构函数）销毁副本。
E.g. 
用普通变量接：T val = func(); → 会拷贝一份副本，之后和原变量无关。
适用于小型对象，但对于大对象会有拷贝开销
return by reference
不会创建副本，直接返回原对象引用，不会产生拷贝，提高性能。适用于返回容器中已有元素，或想让调用者修改原对象的情况。
不能返回局部变量的引用！！！！
因为函数结束后局部变量被销毁，引用悬空
可以返回静态局部变量
static 局部变量存在 静态存储区（data segment/BSS），所以即使函数栈销毁，它的值仍然保留。
静态局部变量，只初始化一次
访问权限（作用域）：它仍然是函数的局部变量，只能在定义它的函数内部访问。
外部无法直接访问，除非通过函数接口（return 或者传引用/指针）间接访问。
Eg.
用引用变量接：T &ref = func(); → ref 和原变量共享一份内存。
return by const reference
不会创建副本，提高性能。防止调用者修改返回的对象，增强安全性。
适用于大对象，但不希望调用者修改数据的情况。
但同样不能返回局部变量的引用，会悬空


function overloading 函数重载
多个同名函数的机制
签名 signature
指的是函数的形参类型及型参个数确定的
编译器根据签名来决定调用哪个函数


抛出异常
类exception是根
大多数 C++ 标准库抛出的错误类型，确实都继承自 std::exception。
try catch 块
catch 块一般包含修复代码，如果无法修复会输出报错信息
为什么需要try catch?
栈解退（stack unwinding）!!!
当一个函数里用 throw 抛出异常，如果当前函数没有 catch 处理：程序会沿着调用栈（stack）逐层往外找能匹配的 catch。在这个过程中，每一层函数中已经构造的局部对象会被自动析构，这就是 栈解退。
如果异常被 catch，程序可以继续安全运行。
如果异常没人管，它会一路冒泡到 main()，最后触发 std::terminate()，直接结束程序。



动态存储空间分配
new  动态内存分配
分配动态内存，如果无法知道数组大小的情况，建议使用try catch检查好，如果无法分配会抛出bad_alloc 异常 来创建未知大小数组
eg.
char(*c)[5];
try {c=new char[n][5];}
catch(bad_alloc)
cerr << “out of memory”;
exit(1)

delete 释放动态内存
delete是用来释放new建立的动态内存，不是删除
如果new时带[] 那么delete [] array ptr 也要带 [] 代表释放整个数组
如果new时没有带[] 那么delete ptr也不需要带


Pointer介绍
指针变量存储的是一个 二进制值，这个值代表内存中某个位置的 唯一标识符
指针随系统架构，32位为4byte，64位为8Byte
指针的大小不随其所指向的数据类型或数据大小而改变!!!
指针的大小只和系统是32位还是64位有关，和它指向的数据类型（int、double 等）无关。就像快递单上的地址标签大小和包裹的实际大小无关一样。
指针只存储地址，不存储数据内容
 合法创建指针的方式3种类
 指向已存在的变量（安全）
int x = 42; int* p = &x;
分配在栈，静态区
动态分配内存（安全，但需手动管理）
分配在堆，动态区
int* p = new int(42);  // 动态分配内存并初始化
// 使用后需手动释
delete p;
 指向NULL/nullptr（安全）
int* p = nullptr;  // 显式初始化为空指针
if (p != nullptr) { /* 安全使用 */ }


一维数组，二维数组 建立和删除
char c[4][5] 已知大小
char (*c)[5] 行数动态，列数固定
char **x 全部动态大小数组





常量函数 const function
量函数（const member function） 的作用主要是用来保证对象的成员函数在调用时不会修改对象的数据成员，起到“只读访问”的作用。

void func(const int& a);
保护传入的变量内容，函数内部不能修改
int getValue() const;
保护的是 调用该函数的对象本身，保证函数不会修改成员变量（除非是 mutable）。

c++ recurisve 递归组成
基础部分base component
递归部分 recurisve component

STL c++标准模版，由一个容器，适配器，迭代器，伪函数和算法 组成 




